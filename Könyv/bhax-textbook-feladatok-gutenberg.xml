<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
        	A könyv elején megismerkedünk az alapfogalmakkal.A számítógépek promgramozási nyelvének 3 szintjét különböztetjük meg:gépi nyelv,assembly szintű nyelv illetve magas szintű nyelv.Mi a magas szintű nyelvekkel foglalkozunk részletesebben.Az ezen a nyelveken megírt programot forrásprogramnak nevezzük.Ezeknek vannak szintaktikai szabályai,ezek az adott kód nyelvtani szabályai.Valamint vannak a szemantikai szabályok a tartalmi,értelmezési illetve jelentésbeli szabályok tartoznak ide.Ezeket a forrásszövegeket kétféleképpen tudjuk gépi kóddá alakítani:fordítóprogramos vagy interpreteres módszerrel.A fordítóprogram lexikális,szintaktikai majd szemantikai elemzést végez, és ez után generál kódot.Ezzel létrejön egy tárgykód, ez már gépi nyelvű,de még nem futtatható.Ez a kód átkerül egy kapcsolatszerkesztő programnak, és így áll elő egy futtatható program.Az interpreteres módszer anniban különbözik,hogy az nem alkot tárgykódot hanem egyből végrehajtja a forráskód feladatait,így egyből kapunk eredményt.Egy program saját szabványát hivatkozási nyelvnek nevezzük.Ebben vannak definiálva a szemantikai illetve a szintaktikai szabályai az adott nyelvnek.Napjainkban már programok írásához grafikus integrált környezetet használnak.
        </para>
        <para>
        	A programnyelveket három féleképpen tudjuk csoportosítani:Imperatív,deklaratív illetve máselvű nyelvek.Az imperatív nyelvek algoritmikusak,utasításokból állnak a változó a legfőbb programozói eszköz és szorosan kötődnek a Neumann-architektúrához.Ezeknek alcsoportjai az eljárásorientált illetve az objektumorientált nyelvek.A deklaratív nyelvek nem kötődnek annyira a Neumann-architektúrához,nem algoritmikusak, a programozó csak a problémát adja meg, nincs lehetőség memóriaműveletre. Alcsoportjai Funkcionális illetve logikai nyelvek.Minden más nyelv a máselvű nyelvek közé sorolható.
        </para>
        <para>
        	A kifejezések segÍtségével,különböző értékekből,új értéket tudunk meghatározni.Ezeknek két összetevőjük van, érték és típus.A kifejezések operandusból,operátorokból illetve kerek zárójelekből állhatnak.Az operátorok a műveleti jelek, a zárójelek segítségével a végrehajtás sorrendjén tudunk változtatni, az operandusok pedig az értékek.Vannak egyoperandusú,kétoperandusú és háromoperandusú kifejezések.Operátor sorrend szerint van infix,postfix és prefix ábrázolás.Az a folyamat amikor a kifejezés értéke és típusa kiszámolásra kerül kiértékelésnek nevezzük.Az infix alak nem egyértelmű, az operátorok erősségét egy precedencia táblázatban adják meg.Az infix teljesen bezárójelezett alakja teljesen egyértelmű.A kifejezés típusát két féleképpen lehet meghatározni. Ha ugyan olyan típusú operandusok vannak a kifejezésben akkor típusegyenértékűség lesz,ha nem akkor pedig típuskényszerítés.A konstansok értéke fordítási időben dőlnek el.A C egy kifejezésorientált nyelv.Típuskényszerítős elvét vallja.A könyv itt bemutatja az operátorokat.
        </para>
        <para>
        	Az adattípusok konkrét programozási eszközök,mindegyiknek van egy neve,ez az azonosítójuk.Egy adattípust három dolog határoz meg:tartomány,műveletek,reprezentáció.Az adattípusok tartománya azokat az értékeket tartalmazza amit felvehet.A reprezentáció megadja,hogy hány bájtos lehet az adott típus.Minden típusos nyelv rendelkezik alap típusokkal, de van olyan is ahol a programozó definiálhat saját típust.Ezzel jobban lehetővé téve a modellezést.Saját típus létrehozáskor a fentebb említett három dolgot kell definiálnia a programozónak.Vannak egyszerű illetve összetett adattípusok. Az egyszerűeket már nem lehet tovább bontani, azonban az összetett összes eleme valamilyen egyszerű típusra bontható.Egyszerű típusok: Egész és valós(lebegőpontos ábrázolás),ezek numerikus típusok ezeken numerikus és összehasonlító műveleteket lehet végrehajtani.Karaktreres típusok tartományába a karakterláncok tartoznak, a sztring pedig karaktersorozatból áll, szöveges és hasonlító műveleteket lehet végezni.Egyes nyelvek ismerik a logikai típust,ez igaz vagy hamis lehet, logikai illetve összehasonlító műveletek végezhetőek el vele.Összetett típusok:Idetartozik a tömb és a rekord.A tömb elemei ugyanolyan típusúak.A tömböt mint típust meghatározza:dimenzióinak száma ,indexkészletének típusa és tartománya és elemeinek a típusa.A C nem ismeri a több dimenziós tömböt ezért úgy képzeljük el,hogy egy  tömb elemei tömbök lesznek.A rekord elemei különböző típusúak lehetnek.A mutató egy adott tárterületre fog mutatni.A nevesített konstans három dologból áll:név,tÍpus és érték.Ezt olyankor használjuk ha egy értéket sokszor szeretnénk használni a programban.Az egész program futása során állandó lesz.A változók négy részből állnak:név,attribútumok,cím és érték.A név egy azonosító, a legfőbb attribútum a típus.Többféleképpen lehet deklarálni:Explicit(a program végzi valami eredményeként),implicit(programozó végzi),automatikus(a fordítóprogram végzi).A cím a tárterületet adja meg ahol tárolva van.Többféleképpen lehet tárterületet hozzárendelni,ezt a könyv részletesen taglalja.Értéket adhatunk értékadó utasítással,kezdőértékadással.
        </para>
        <para>
        	Ezután megismerkedünk a C-ben lévő típusokkal majd láthatunk pár példát deklarációra. A typedefet is taglalja a könyv valamint a struktúra megadását is.
        </para>
        <para>
        	Ezekután az utasításokról olvashatunk részletesen.A fordító ezek segítségével készíti el a tárgyprogramot.Két csoportja van: deklarációs és végrehajtható, az utóbbit használja a tárgykód elkészítéséhez.Ezeknek 9 csoportja van:értékadó utasítás,üres utasítás,ugró utasítás(go to),elágaztató utasítás(if,if else, switch),ciklusszervező utasítások(while,for,do while),vezérlésátadó(ontinue,brek return),I/O illetve egyéb utasítások. Ezeket a könyv részletesen írja le illetve példákat is mutat rá.
        </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>    
        <para>
        A könyv vezérlési szerkezetek című fejezetében a különbüző ilyen szerkezeteket írja le a könyv részletesen. Ezekkel a vezérlési szerkezetekkel határozhatjuk meg,hogy a program a különböző műveleteket milyen sorrendben hajtsa végre.Egy kifejezés,pl egy deklaráció,vagy függvény meghívás akkor válik utasítássá ha egy pontos vesszőt teszünk utána.Kapcsos zárójeek segítségével ún. blokkokat hozhatunk létre. Ezekben a blokkokban több utasítás lehet. Ezt pl az if-nél használjuk.Az if-else utasítással döntéseket hozhatunk.Az if után zárójelek között kell megadnunk a vizsgált kifejezést, és ha az igaz lesz(nem nullát kapunk vissza) akkor az if utáni utasítást végrehajtja a program,ha hamis lesz akkor pedig tovább ugrik az else ágra.Az else ágat el lehet hagyni,illetve az if után blokk is állhat.Az else-if segítségével több if-et is megadhatunk, és a program futása során az összesest megfogja vizsgálni,és ha egyik sem lesz igaz,csak akkor ugrik majd az else ágra.A switch utasítással többirányú elágazást hozhatunk létre a programban.A switch szó után zárójelek között megadjuk a vizsgált kifejezést, majd case szó után megadunk még egy kifejezést, és ha az a kifejezés igaz lesz akkor az utána lévő utasítást hajtja végre a program.Akármennyi case-t létrehozhatunk.Tehát például ha egy dolgozatot szeretnénk osztályozni akkor a dolgozat pontszámát beírjuk a switch mögé, a case szavak után pedig a különböző ponthatárokat és azután,hogy az hanyas érdemjegynek felel meg.A program ki fogja választani ,hogy melyik intervallumba illik be a pontszám és kiírja az érdemjegyet.Az utasítás végén megadhatunk egy default értéket, ez akkor fog végrehajtódni ha egyik esetre se igaz az adott kifejezés. Tehát például ha valakinek több pontja lenne mint a max pontszám akkor a default utasítás hajtódna végre.A break utasítással bármelyik utasításból kiléphetünk manuálisan.A while illetve for utasításokkal ciklusokat hozhatunk létre a programban.A while után zárójelek között kell megadnunk egy kifejezést,ez a ciklus mindaddig fog futni amíg a a kifejezés igaz lesz(akkor áll meg ha hamissá válik).Ha igaz, akkor a megadott utasítást végrehajtja.A for utasítással is ciklusokat  tudunk létrehozni a programban. Ilyenkor a for szócska után zárójelben 3 kifejezést kell megadnunk.A zárójelben az első kifejezésben megadjuk azt ahonnan indulunk(vagy értékadással vagy egy függvénnyel),a második kifejezés általában egy relációs kifejezés, ezt fogja vizsgálni a program(ha igaz akkor fog lefutni) a harmadik kifejezéssel általában a ciklusváltozóval csinálunk valamit(vagy növeljük vagy csökkentjük).A for ciklust nagyon egyszerűen át tudjuk írni while ciklusra. Az első kifejezést kell a while elé írnunk, a második kifejezés a while utáni zárójelbe kerül, a 3.kifejezés pedig utasításként a while utáni blokkba kerül.Az,hogy melyik ciklust használjuk az adott programban,teljesen a programozóra van bízva. Általában at használjuk amelyik kézenfekvőbbnek tűnik.Ha a for ciklus utáni zárójelek közé két pontosvesszőt írunk,akkor egy végtelen ciklust hozunk létre. Ilyenkor a 2.kifejezést mindig igaznak fogja kiértékelni a program és a break utasítással vagy a return utasítással tudunk manuálisan kilépni a ciklusból.A while és for ciklusok feltételeit a program mindig a ciklus futása előtt ellenőrzi le, így előfordulhat az,hogy az adott ciklus egyszer sem fut le(ha a feltétel a kezdetektől fogva hamis ). Ezekkel ellentétben a do-while ciklus ún. hátultesztelős ciklus,azaz egyszer biztosan lefog futni,mivel csak a ciklus futása végén ellenőrzi a feltétel igazságát.Ezt a ciklust sokkal ritkábban használják,de ritkán nagyon hasznos.A break utasítással az előbb már átbeszélt utasításokból idő előtt ki tudunk lépni.A continue utasítás a switch utasításban nem használható.A while esetén ez az utasítás azt fogja eredményezni,hogy egyből végrehajtja a feltételvizsgálatot. Általánosan pedig a kövektkező utasításra ugrik.A goto utasítással egy címkére ugorhatunk,általában nem használják.De ha igen akkor a leggyakoribb felhasználási módszere,ha több egybeágyazott ciklusból szeretnénk kilépni,ugyanis itt nem használható a break utasítás.
</para>    
<para>
	Ezek az utasítások leírásuk sorrendjében hajtódnak végre illetve különböző sorrendbe sorolhatóak.Hat fő csoportba tudjuk sorolni az utasításokat.A címkézett utasításoknál előtagkén egy címkét írhatunk az utasítás elé.Ez a címke egy azonosítóból áll.A következő csoport a kifejezés utasítás, a legtöbb utasítás ilyen. Ide tartozik a függvény hívás vagy az értékadás, pontosvesszővel zárjuk le.Az összetett utasítások csoportjába tartozik a blokk. Ezáltal több utasítást egy utasításként tudunk kezelni.Ezt a kapcsos zárójelekkel tehetjük meg.A kiválasztó utasítások közé tartozik az if illetve a swicth utasítás.Az ebbe a csoportba tartozó utasítások már megváltoztatják a végrehajtási sorrendet.Az if-el található else utasítás mindig a blokkban lévő utolsó if-el van párban.A switch utasítás után bármennyi case állhat,default viszont csak egy.Az iterációs utasítások csoportjába tartozik a while,do-while illetve for utasítások.Ezek egy ciklust definiálnak.A vezérlésátadó csoportba a goto,continue,break illetve return utasítások tartoznak.Ezekkel feltétel nélkül átadhatjuk a vezérlést.A goto működéséhez szükséges egy címke,amire át fog térni a vezérlés.A continue utasítással egy ciklusban újra megvizsgálásra kerül a feltétel.A break-el a következő utasításra ugordhatunk.A returnel visszatérítési értéket adhatunk meg.
	</para>
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>A könyv részletesen fejti ki az objektumorientáltságot.A C++ mint már tudjuk objektumorientált nyelv, ezáltal összetebb problémákat lehet vele megoldani azonban ez teljesítménycsökkenéssel járhat.A C++-ban osztályokat használunk,aminek minden elemét egyednek hívunk.Fontos megemlíteni az adatrejtést, ez azt jelenti,hogy az osztályon belüli bizonyos adatok más programrésznek nem elérhetőek.A könyv tárgyalja a tagfüggvények különböző megadását illetve a tagváltozókról is beszél.Az adatrejtést is kifejti ezután a szerző, elmagyarázza,hogy azért fontos a különböző adatok védelme,hogy azokat más ne tudja megváltoztatni,ugyanis lehet olyan függvény ami azzal az értékkel számol.Ezután szó van a konstruktorról illetve a destruktorról. A konstruktor egy új példány létrehozásakor hívódik meg, és ez foglalja le számára a memóriát. A destruktor pedig egy példány törlésekor felszabadítja a memóriát.A dinamikus adatkezelésről is olvashatunk. Memóriát lefoglalni a new operátorral, a delete operátorral pedig a lefoglalt memóriát törölhetjük.A másolókonstruktorról is olvashatunk, ami egy adott példányt fog lemásolni, ez akkor fog meghívódni ha egy függvényt értékszerinti paraméterátadással hívunk meg,így nem fog változni az eredeti példány.Létezik sekély(bitenként másol) illetve mély másolás.Majd a friend függvényeket írja le a könyv, a friend függvények úgyanúgy hozzáférnek a tagfüggvényekhez és a tagváltozók, mintha az osztály tagjai lennének.Friend osztályok is léteznek,ezeknek is ugyanaz a joguk lesz mintha az adott osztályba tartoznának.A statikus tagváltozók az osztály minden objektumában ugyanazt az értéket veszik fel.Az operárotorok kiértékelési sorrendje az ún. precedenciatáblázatban van leírva, ezt a sorrendet zárójelek segítségével tudjuk befolyásolni.C++-ban az operátorok túlterhelésével,saját operátorokat hozhatunk létre.Itt a szerző különböző példákkal magyarázza el az operátor túltöltését.
        </para>
        <para>
        	A 10.fejezetben a kivételkezelésről olvashatunk. C-ben a hibákról, a függvények által visszatérített hibakódokkal illetve globális változókkal tudunk tájékozódni. C++-ban azonban létrehozhatunk ún. kivételkezelést. Ezáltal sokkal átláthatóbb illetve könnyebben kezelhető lesz a hibakezelésünk.Ebben a fejezetben megismerjük a C-ben lévő hibakezelés problémáit. Illetve arra is kapunk segítséget,hogy hogyan kereljük el a memóriszivárgást a kivételkezelés során.C-ben ha egy függvényhívás láncot nézünk és valamelyik függvény hibát észlel(például nem tud megnyitni egy fájlt) akkor a visszatérési értékéből tudjuk meg a hibát, ezt a kódot visszaadja egész az első láncszemig, a main függvényig. A main függvényben pedig kezeljük azt.Ez nagyon körülményes illetve nagyon könnyű átsiklani a hibákon, így könnyen előfordulhat az,hogy hibás adattal fogunk dolgozni.Ezeket a hibákat tudjuk kiküszöbölni a C++-os kivételkezeléssel. Kivételkezeléskor ugyanis a futás azonnal a hibakezeléses részlegre fog kerülni. Ezzel a módszerrel nem csak hibát,hanem bármilyen kivételes esetet tudunk kezelni.A 190.oldali példában egy try-catch blokkot találunk.Ha megfelelő számot írunk be akkor a try blokkban lévő majdnem összes utasítás lefog futni, majd a végén kiírja a program,hogy done. Ilyenkor csak a throw utasítás nem fut le. Ha azonban nem megfelelő értéket írunk be akkor a throw utasítással egy kivételt dobunk, jelen esetben const char* típusú stringet, ilyenkor a vezérlés azonnal átkerül az ugyan ilyen kivételt 'elkapó' catch-re,és végrehajtódik a megadott utasítás.Ha egy függvény hívási láncot nézünk akkor ilyenkor egyből a megfelelő catch ágra fog kerülni a vezérlés, és nem a main függvényre. Ha egy kezeletlen kivétellel találkozik a program akkor az abort függvény hívódik meg amely a programból való kilépést eredményezi.Több try-catch blokkot egybe tudunk ágyazni illetve egy kivételt többször is dobhatunk.A 197.oldalon a verem visszacsévélésére látuk egy példát. Ez az a jelenség mikor egy kivétel dobásakor és elkapásáig a lokális változók felszabadulnak.Ebből az a tanulság,hogy kivétel dobás és elkapás között kód futhat le.
        </para>
    </section>        
</chapter>                
